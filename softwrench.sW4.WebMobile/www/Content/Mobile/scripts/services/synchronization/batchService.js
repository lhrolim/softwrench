(function (mobileServices, angular, persistence) {
    'use strict';

    //#region Service registration
    mobileServices.factory('batchService', ['$q', 'offlineRestService', 'swdbDAO', '$log', 'schemaService', 'offlineSchemaService', 'operationService', 'dispatcherService', 'offlineEntities', "attachmentDataSynchronizationService", service]);
    //#endregion

    function service($q, restService, swdbDAO, $log, schemaService, offlineSchemaService, operationService, dispatcherService, entities, attachmentDataSynchronizationService) {

        //#region Utils

        //#region DataEntry Rollback
        /**
         * internal rollback context
         */
        var rollbackContext = {
            // Queue: DataEntry instances currently being submitted to the server
            submittingEntries: []
        };

        var logIdsIfEnabled = function (logger, level, entities, messageTemplate) {
            // just so it doesn't waste time and memory creating a message that won't be logged
            if (!logger.isLevelEnabled(level)) {
                return;
            }
            const ids = entities.map(function (e) {
                return "'{0}'".format(e.id);
            });
            logger[level](messageTemplate.format(ids));
        };

        /**
         * Adds the dataentry to the rollbackcontext.
         * 
         * @param [DataEntry] dataentry either an array of entries or a single entry
         */
        var addToRollbackContext = function (dataentry) {
            const log = $log.get("BatchService#rollback");
            if (angular.isArray(dataentry)) {
                logIdsIfEnabled(log, "debug", dataentry, "marking DataEntries {0} to rollback");
                angular.forEach(dataentry, function(e) {
                    rollbackContext.submittingEntries.push(e);
                });
            } else {
                log.debug("marking DataEntry '{0}' to rollback".format(dataentry.id));
                rollbackContext.submittingEntries.push(dataentry);
            }
        };

        /**
         * Updates the entries added to the rollbackcontext
         * setting their pending property to false.
         * 
         * (?) If the rollbackk mechanism fails for any reason the entries 
         * will remain in the rollbackcontext. (?)
         */
        var rollBackSubmittingDataEntries = function () {
            var log = $log.get("BatchService#rollback");
            log.debug("executing rollback");
            var nonPendingEntries = [];
            while (rollbackContext.submittingEntries.length > 0) {
                // evicting entries from internal state
                const entry = rollbackContext.submittingEntries.shift();
                if (!entry) continue;
                // mark as not pending
                entry.pending = false;
                // pushing to this function scoped state
                nonPendingEntries.push(entry);
            }
            swdbDAO.bulkSave(nonPendingEntries)
                .then(function (entries) {
                    logIdsIfEnabled(log, "debug", entries, "DataEntries {0} rolledback successfully");
                }).catch(function (error) {
                    logIdsIfEnabled(log, "warn", nonPendingEntries, "Failed to rollback DataEntries {0} due to " + error);
                    // (?) addToRollbackContext(nonPendingEntries); (?)
                });
        };

        /**
         * Empties the rollbackcontext.
         * 
         * (?) Maybe do a per-entry eviction: only remove those passed as arguments. 
         * Useful if we decide to maintain the entries in the context if their rollback fail (?)
         */
        var evictRollBackContext = function() {
            rollbackContext.submittingEntries = [];
        };

        //#endregion

        function generateDatamapDiff(batchItem) {
            if (batchItem.operation) {
                return batchItem.operation.datamap;
            }
            const datamap = batchItem.dataentry.datamap; //TODO: implement the diff, passing also the ID + siteid all the time
            return datamap;
        };

        //#region Post-Batch Handlers
        var postBatchHandlers = [];
        
        /**
         * Adds a handler callback to be executed before a Batch submit request.
         * The callback function receives the just created Batch, the request parameters and the request payload 
         * as arguments in this order.
         * The callback should return either the payload received as argument (possibly modified by it) 
         * or a promise that resolves with it to continue the callback chain.
         * The payload received by the next callback in the chain will be the payload generated by the previous one.
         * 
         * @param function handler 
         */
        function onBeforeBatchSubmit(handler) {
            postBatchHandlers.push(handler);
        }

        /**
         * Executes the callbacks in a promise chain in a way similar to a 
         * 'chain-of-responsability' pattern.
         * Made a small jsfiddle to quickly test it: http://jsfiddle.net/dEkgK/8/
         * 
         * @param Batch batch 
         * @param {} params 
         * @param {} payload 
         * @returns Promise resolved with payload updated by the handlers 
         */
        function executePostBatchHandlers(batch, params, payload) {
            if (postBatchHandlers.length <= 0) return $q.when(payload);
            var promise = null;
            var payloadToUse = angular.copy(payload);
            // sequentially promise chaining
            angular.forEach(postBatchHandlers, function(handler) {
                if (!promise) {
                    promise = $q.when(handler(batch, params, payloadToUse));
                } else {
                    promise = promise.then(function(result) {
                        payloadToUse = !!result ? result : payloadToUse;
                        return handler(batch, params, payloadToUse);
                    });
                }
            });
            return promise;
        }

        //#endregion

        //#endregion

        //#region Public methods

        function getIdsFromBatch(batch) {
            const items = batch.items;
            const ids = [];
            for (let i = 0; i < items.length; i++) {
                const batchItem = items[i];
                ids.push(batchItem['remoteId']);
            }
            return ids;
        };

        /**
         * Saves a Batch it's children BatchItems and another possible 
         * list of a related entity (such as DataEntry or Problem) in a single transaction.
         * This method requires all parameters to be currently in a persistence "managed" state
         * i.e. they need to be actual entity instances, it won't work with "simple" objects/dictionaries.
         * 
         * @param Batch batch 
         * @param [BatchItem] batchItems (optional) 
         * @param [persistence.Entity] managedEntities (optional)
         * @returns Promise: resolved with the saved batch; rejected with Database error
         */
        function saveBatch(batch, batchItems, managedEntities) {
            var log = $log.getInstance("batchService#saveBatch");
            var deferred = $q.defer();
            persistence.transaction(function (tx) {
                log.debug("executing batching db tx");
                //save managed entities before the batchItems so that their properties are not null for loaded items
                if (managedEntities) swdbDAO.bulkSave(managedEntities, tx);
                if (batchItems) swdbDAO.bulkSave(batchItems, tx);
                swdbDAO.save(batch, tx);
                persistence.flush(tx, function () {
                    batch.items.list(null, function (results) {
                        batch.loadeditems = results;
                        return deferred.resolve(batch);
                    });
                });
            });
            return deferred.promise;
        }

        /**
         * Updates a local Batch entity according to a Batch response from the server.
         * The updates includes: updating related BatchItem's problems, updating related DataEntries's flags
         * and updating status of the Batch and the realted entities. 
         * The method also checks if the remoteBatch is a synchronous/asynchronous response 
         * and takes the correct action flow.
         * 
         * @param Batch batch entity 
         * @param Object remoteBatch Batch response from server 
         * @returns Promise: resolved with the updated Batch. 
         */
        function updateBatch(batch, remoteBatch) {
            const log = $log.get("batchService#updateBatch");
            var returnedBatchStatus = remoteBatch.status;
            batch.status = returnedBatchStatus; // always update status
            var indexedItems = {}; // items indexed by their id
            batch.loadeditems.forEach(function (item) {
                // status update
                item.status = returnedBatchStatus;
                // indexing items
                indexedItems[item.id] = item;
            });
            log.info("Batch response received (id='{0}') with Batch.status = '{1}'".format(remoteBatch.remoteId, returnedBatchStatus));
            // assynchronous case: awaiting to be processed
            if (returnedBatchStatus !== "COMPLETE") {
                // update batch status
                return saveBatch(batch, batch.loadeditems);
            }
            // synchronous case: request already processed
            // has to update with problems and/or success
            const problems = remoteBatch.problems; // indexed by related batchItem.id
            const problemEntities = [];
            for (let itemId in problems) {
                if (!problems.hasOwnProperty(itemId)) continue;
                // instantiate Problem (synchronously actually helps in this case)
                const problem = problems[itemId];
                const problemEntity = new entities.Problem();
                problemEntity.message = problem.message;
                // item pointing to Problem and status update
                const problematicItem = indexedItems[itemId.toUpperCase()]; // uppercasing in case the server camelcased the keys
                problematicItem.problem = problemEntity;
                // add to array
                problemEntities.push(problemEntity);
            }
            const successItems = remoteBatch.successItems;
            angular.forEach(successItems, function(successId) {
                const successItem = indexedItems[successId.toUpperCase()]; // uppercasing in case the server camelcased the keys
                if (successItem.problem) successItem.problem = null; // problem shouldn't be deleted for history purposes
            });
            // update items's DataEntries's flags
            angular.forEach(batch.loadeditems, function (item) {
                item.dataentry.pending = false;
                item.dataentry.isDirty = !!item.problem;
            });
            // save problems, update statuses and flags
            const hasProblems = problemEntities.length;
            batch.hasProblems = hasProblems;
            if (hasProblems > 0) {
                return saveBatch(batch, batch.loadeditems, problemEntities);
            }
            // no problems found: just update statuses and flags
            return saveBatch(batch, batch.loadeditems);
        }

        /**
         * Executes a request to submit a Batch and handles the returned response.
         * 
         * @param Batch batch 
         * @param [Object] items to be sent as payload
         * @returns Promise: resolved with updated Batch; rejected with Http or Database error 
         */
        function doSubmitBatch(batch, items) {
            var log = $log.getInstance('batchService#doSubmitBatch');
            // preparing the request
            var batchParams = {
                application: batch.application,
                remoteId: batch.id,
                downloadImmediately: batch.forcedownload || false //used for quick sync
            }
            var objectToSend = { items: items };
            // execute all handlers and send the result
            return executePostBatchHandlers(batch, batchParams, objectToSend)
                .then(function (result) {
                    const jsonToSend = !!result ? angular.toJson(result) : angular.toJson(objectToSend); // performing the request
                    log.info("Submitting a Batch (id='{0}') to the server.".format(batch.id));
                    return restService.post("Mobile", "SubmitBatch", batchParams, jsonToSend);
                }).then(function (response) {
                    const returnedBatch = response.data;
                    return updateBatch(batch, returnedBatch);;
                });;
        };

        function submitBatches(batches) {
            const log = $log.getInstance('batchService#submitBatches');
            var promises = []; // parallel requests promises
            batches.forEach(function (batch) {
                if (!batch || !batch.loadeditems) {
                    return;
                }
                const items = batch.loadeditems.map(batchItem => {
                    return {
                        datamap: generateDatamapDiff(batchItem),
                        itemId: batchItem.dataentry.remoteId,
                        //local id becomes remote from the server perspective
                        remoteId: batchItem.id,
                        application: batch.application,
                        operation: batchItem.crudoperation,
                        dataentry: batchItem.dataentry.id,
                        additionaldata: {}
                    };
                }); // put the batch submission promise in the array
                promises.push(doSubmitBatch(batch, items));
            });

            // no batches were submitted: reject it
            if (promises.length <= 0) {
                log.info("no batches submitted");
                return $q.when();
            }

            // joined promises: resolves with array of Batch
            return $q.all(promises)
                .then(function (results) {
                    // entries can be removed from rollbackcontext
                    evictRollBackContext();
                    return results;
                })
                .catch(function (error) {
                    // rollback DataEntries update
                    rollBackSubmittingDataEntries();
                    // still reject the error to communicate it along the promise chain
                    return $q.reject(error);
                });
        };


        /**
         * Creates a batch for all the items marked as a dirty on a given application or for a particular item passed as a parameter
         * @param {} dbapplication 
         * @param {} dataEntryToSync 
         * @returns {} 
         */
        function createBatch(dbapplication, dataEntryToSync) {
            var applicationName = dbapplication.application;
            const log = $log.getInstance('batchService#createBatch',["sync","batch"]);
            const detailSchema = offlineSchemaService.locateSchemaByStereotype(dbapplication, "detail");
            const queryToUse = "isDirty=1 and pending=0 and application='{0}'".format(applicationName);
            const promiseToUse = dataEntryToSync != null ? $q.when([dataEntryToSync]) : swdbDAO.findByQuery('DataEntry', queryToUse);

            return promiseToUse
                .then(dataEntries => attachmentDataSynchronizationService.mergeAttachmentData(applicationName,dataEntries))
                .then(dataEntries => {

                    if (!dataEntries || dataEntries.length <= 0) {
                        log.debug("no items to submit to the server. returning null batch");
                        return null;
                    }

                    var batchItemPromises = [];

                    angular.forEach(dataEntries, function(entry) {
                        // execute per application registered pre-sync service
                        const mobilePresyncserviceName = dbapplication.data.parameters["mobile.presyncservice"];
                        if (!!mobilePresyncserviceName) {
                            dispatcherService.invokeServiceByString(mobilePresyncserviceName, [entry.datamap, entry.originaldatamap]);
                        }

                        // if batch submission fails, remember to rollback this state (otherwise dataentry will be in limbo)
                        entry.pending = true;
                        addToRollbackContext(entry);

                        batchItemPromises.push(swdbDAO.instantiate('BatchItem', entry, function(dataEntry, batchItem) {
                            batchItem.dataentry = dataEntry;
                            batchItem.status = 'pending';
                            batchItem.label = schemaService.getTitle(detailSchema, dataEntry.datamap, true);
                            batchItem.crudoperation = operationService.getCrudOperation(dataEntry, detailSchema);
                            return batchItem;
                        }));
                    });
                    var dbPromises = [];
                    log.debug('creating db promises');
                    var batchPromise = swdbDAO.instantiate('Batch');
                    dbPromises.push(batchPromise);
                    dbPromises.push($q.when(dataEntries));
                    dbPromises = dbPromises.concat(batchItemPromises);
                    return $q.all(dbPromises);
                }).then(function(items) {
                    if (!items) {
                        return items;
                    }
                    const batch = items[0];
                    const dataEntries = items[1];
                    const batchItemsToCreate = items.subarray(2, length + 1);
                    batch.application = applicationName;
                    batch.sentDate = new Date();

                    for (let i = 0; i < batchItemsToCreate.length; i++) {
                        //creating relationships
                        const item = batchItemsToCreate[i];
                        batch.items.add(item);
                        item.batch = batch;
                    }
                    return saveBatch(batch, batchItemsToCreate, dataEntries);
                });
        }

        //#endregion
        
        //#region Service instance
        const api = {
            getIdsFromBatch,
            submitBatches,
            generateDatamapDiff,
            createBatch,
            saveBatch,
            updateBatch,
            onBeforeBatchSubmit
        };
        return api;

        //#endregion
    };
    
  

})(mobileServices, angular, persistence);





