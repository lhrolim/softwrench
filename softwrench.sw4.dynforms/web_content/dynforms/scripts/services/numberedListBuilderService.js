
(function (angular) {
    "use strict";

    const formsInfo = {
        app: "_FormMetadata",
        schemaid: "listselection",
    }

    const cloneModalInfo = {
        app: "_FormMetadata",
        schemaid: "detail",
    }


    const defaultValues = {
        startIndex: 1,
        treeTemplate: "checklist"
    }


    const baseTemplate = (label, attribute, startIndex, treeTemplate, rendererParameters, extraHeaderStyle, extraHeaderLabel) => {

        rendererParameters = rendererParameters || {};
        rendererParameters["template"] = treeTemplate;
        rendererParameters["extraheaderlabel"] = extraHeaderLabel;
        rendererParameters["extraheaderstyle"] = extraHeaderStyle;

        return {
            "$type": `softwrench.sW4.Shared2.Metadata.Applications.Schema.TreeDefinition, softwrench.sw4.Shared2`,
            "type": "TreeDefinition",
            "showExpression": "true",
            "label": label,
            "isReadOnly": false,
            "attribute": attribute,
            "role": attribute,
            "listType": "number",
            "displayables": [],
            "nodes": [],
            rendererParameters,
            "startIndex": startIndex
        }
    }

    const nodeFieldTemplate = (nodeAttribute) => {
        const field = {
            "$type": `softwrench.sW4.Shared2.Metadata.Applications.Schema.ApplicationFieldDefinition, softwrench.sw4.Shared2`,
            "enableDefault": "true",
            "autoGenerated": false,
            "isHidden": false,
            "renderer": {
                "parameters": {}
            },
            "isAssociated": false,
            "rendererParameters": {},
            "filterParameters": {},
            "applicationName": "_FormDatamap",
            "label": "",
            "attribute": nodeAttribute + "_input",
            "requiredExpression": "false",
            "showExpression": "true",
            "enableExpression": "true",
            "isReadOnly": false,
            "type": "ApplicationFieldDefinition",
            "role": nodeAttribute + "_input"
        }
        return field;
    }

    const nodeTemplate = (nodeLabel, nodeAttribute, treeTemplate) => {
        const fields = [];
        if (treeTemplate === "inputchecklist") {
            fields.push(nodeFieldTemplate(nodeAttribute));
        }

        return {
            "$type": `softwrench.sW4.Shared2.Metadata.Applications.Schema.TreeNode, softwrench.sw4.Shared2`,
            "type": "TreeNode",
            "showExpression": "true",
            "label": nodeLabel,
            "isReadOnly": false,
            "attribute": nodeAttribute,
            "role": nodeAttribute,
            "listType": "letterdot",
            "displayables": fields
        }
    }

    const createHeaderFields = (attribute, extraHeaderStyle, extraHeaderLabel) => {

        const rendererType = extraHeaderStyle === "label" ? "label" : "default";

        return {
            "$type": `softwrench.sW4.Shared2.Metadata.Applications.Schema.ApplicationFieldDefinition, softwrench.sw4.Shared2`,
            "enableDefault": "true",
            "autoGenerated": false,
            "isHidden": false,
            "renderer": {
                "rendererType": rendererType,
                "parameters": {}
            },
            "isAssociated": false,
            "rendererType": rendererType,
            "rendererParameters": {},
            "filterParameters": {},
            "applicationName": "_FormDatamap",
            "label": extraHeaderLabel,
            "attribute": attribute,
            "requiredExpression": "false",
            "showExpression": "true",
            "enableExpression": "true",
            "isReadOnly": false,
            "type": "ApplicationFieldDefinition",
            "role": attribute,
        };

    }

    const addInputToNodes = (nodes) => {
        if (!nodes) {
            return;
        }
        nodes.forEach(n => {
            n.displayables = n.displayables || [];
            n.displayables.push(nodeFieldTemplate(n.attribute));
            addInputToNodes(n.nodes);
        });
    }

    const removeInputFromNodes = (nodes) => {
        if (!nodes) {
            return;
        }
        nodes.forEach(n => {
            n.displayables = [];
            removeInputFromNodes(n.nodes);
        });
    }

    class numberedListBuilderService {

        constructor($log, alertService, fieldService) {
            this.$log = $log;
            this.alertService = alertService;
            this.fieldService = fieldService;
            this.LOG = $log.get(this.constructor.name);
        }


        //#region Utils
        createList({ fattribute, flabel, startIndex, treeTemplate, nodes, displayables, extraHeaderStyle, extraHeaderLabel } = defaultValues, rendererParameters) {
            const originalTemplate = rendererParameters["template"];
            const baseList = baseTemplate(flabel, fattribute, startIndex, treeTemplate, rendererParameters, extraHeaderStyle, extraHeaderLabel);
            if (!nodes || nodes.length === 0) {
                //creation
                this.addRow(baseList);
            } else {
                if (originalTemplate !== treeTemplate) {
                    if (treeTemplate === "inputchecklist") {
                        addInputToNodes(nodes);
                    } else if (treeTemplate === "checklist") {
                        removeInputFromNodes(nodes);
                    }
                }
                baseList.nodes = nodes;
            }

            const hasHeaderFields = displayables && displayables.length !== 0;

            if ((!hasHeaderFields) && extraHeaderStyle !== "none") {
                baseList.displayables.push(createHeaderFields(fattribute + "_header", extraHeaderStyle, extraHeaderLabel));
            } else if (hasHeaderFields && extraHeaderStyle === "none") {
                baseList.displayables = [];
            } else if (hasHeaderFields) {
                displayables[0].label = extraHeaderLabel;
                baseList.displayables = displayables;
            }

            


            return baseList;
        }

        addRow(fieldMetadata, currentNode) {
            const treeTemplate = fieldMetadata.rendererParameters["template"];
            const fattribute = fieldMetadata.attribute;

            if (currentNode == null) {
                fieldMetadata.nodes.push(nodeTemplate("", fattribute + "_1", treeTemplate));
                //inserting at bottom of the tree, first time
            } else {
                const data = this.locateNode(fieldMetadata, currentNode);

                const lastidx = currentNode.attribute.lastIndexOf("_");
                const attrIdx = currentNode.attribute.substring(lastidx + 1);

                //either a string number or char converts to next here
                const nextIdx = String.fromCharCode(attrIdx.charCodeAt(0) + 1);
                const nextAttribute = replaceAll(currentNode.attribute, attrIdx, nextIdx);

                data.container.nodes.splice(data.realIdx + 1, 0, nodeTemplate("", nextAttribute, treeTemplate));
            }
        }

        calcIndex(listtype, nodeindex, startindex) {
            if (!listtype) {
                return "";
            }

            const index = 1 + nodeindex + (startindex ? Number.parseInt(startindex) : 0);
            if (listtype === "number") {
                return index;
            }
            return String.fromCharCode(index + 96);
        }

        advanceFocus(advance) {
            var $focused = $(':focus');
            if (!$focused || $focused.length === 0) {
                //shouldn´t happen but playing safe...
                return;
            }
            const els = $('[data-metadatatype="nodeedition"]').toArray();
            const currIdx = els.findIndex(el => el === $focused[0]);
            const nextIdx = !!advance ? currIdx + 1 : currIdx - 1;
            if (nextIdx >= 0 && nextIdx < els.length) {
                els[nextIdx].focus();
            }
        }

        addNodeInput(node) {
            node.displayables = node.displayables || [];
            node.displayables.push(nodeFieldTemplate(node.attribute));
        }

        adjustAttributeName(rootTree, fieldMetadata, idx) {
            const fattribute = rootTree.attribute;
            fieldMetadata.attribute = fattribute + "_{0}".format(idx);
        }


        identUp(rootTree, fieldMetadata) {
            const data = this.locateNode(rootTree, fieldMetadata);
            const realIdx = data.realIdx;
            const nodeArray = data.container.nodes;
            if (realIdx === 0) {
                //we cannot identup the first node of the tree
                return;
            }



            const predecessor = nodeArray[realIdx - 1];

            //removing the item from the current location
            nodeArray.splice(realIdx, 1);

            //adding it to the list of nodes of the predecessor (ex: 2 becomes 1.a)
            predecessor.nodes = predecessor.nodes || [];

            fieldMetadata.attribute = predecessor.attribute + "_" + this.calcIndex(predecessor.listType, predecessor.nodes.length);
            fieldMetadata.role = fieldMetadata.attribute;


            predecessor.nodes.push(fieldMetadata);
        }

        identDown(rootTree, fieldMetadata) {
            const data = this.locateNode(rootTree, fieldMetadata);
            const realIdx = data.realIdx;
            const container = data.container;
            if (container === rootTree) {
                //we cannot ident down a node which is alraedy at the root tree level
                return;
            }
            //removing the item from the current location
            container.nodes.splice(realIdx, 1);

            const parentData = this.locateNode(rootTree, container);

            const parentContainer = parentData.container;
            const parentIdx = parentData.realIdx;

            fieldMetadata.attribute = parentContainer.attribute + "_" + this.calcIndex(parentContainer.listType, parentIdx + 1);
            fieldMetadata.role = fieldMetadata.attribute;

            parentContainer.nodes.splice(parentIdx + 1, 0, fieldMetadata);
        }

        locateNode(rootTree, fieldMetadata) {
            const attribute = fieldMetadata.attribute;
            let currU = attribute.indexOf("_", rootTree.attribute.length);
            let nextU;
            let container = rootTree;
            let nodeArray;
            let realIdx;
            do {
                container.nodes = container.nodes || [];

                nodeArray = container.nodes ;
                nextU = attribute.indexOf("_", currU + 1);
                let attrIdx;
                if (nextU !== -1) {
                    attrIdx = attribute.substring(currU + 1, nextU);
                    currU = nextU;
                } else {
                    attrIdx = attribute.substring(currU + 1);
                }
                realIdx = String.fromCharCode(attrIdx.charCodeAt(0) - 1);
                if (isNaN(attrIdx)) {
                    //letters 
                    realIdx = attrIdx.charCodeAt(0) - 97;
                }
                var node = nodeArray[realIdx];
                if (nextU !== -1) {
                    container = node;
                }
            } while (nextU !== -1);
            return { container, realIdx: parseInt(realIdx) };
        }

        validateNodeLabelPresent(node) {
            let blankLabelArray = [];
            if (isNullOrEmpty(node.label)) {
                blankLabelArray.push(node.attribute);
            }
            if (node.nodes) {
                node.nodes.forEach(inner => {
                    blankLabelArray = blankLabelArray.concat(this.validateNodeLabelPresent(inner));
                });
            }
            return blankLabelArray;
        }

        validateTrees(trees) {
            if (trees == null || trees.length === 0) {
                return true;
            }

            var blankNodeArray = [];

            trees.forEach(t => {
                t.nodes.forEach(n => {
                    blankNodeArray = blankNodeArray.concat(this.validateNodeLabelPresent(n));
                });
            });
            if (blankNodeArray.length > 0) {
                this.alertService.alert(
                    `Some items do not contain a label, please review your form ${blankNodeArray.join(',')}`);
            }

            return blankNodeArray.length === 0;
        }

        removeNode(rootTree, fieldMetadata) {
            const data = this.locateNode(rootTree, fieldMetadata);
            const realIdx = data.realIdx;
            const nodeArray = data.container.nodes;

            if (realIdx !== -1 && nodeArray != null) {
                if (nodeArray !== rootTree.nodes || nodeArray.length !== 1) {
                    //avoid deleting the first row, that would make the whole tree useless
                    nodeArray.splice(realIdx, 1);
                }

            }
        }

    }


    numberedListBuilderService["$inject"] = ["$log", "alertService", "fieldService"];

    angular.module("sw_layout").service("numberedListBuilderService", numberedListBuilderService);

})(angular);