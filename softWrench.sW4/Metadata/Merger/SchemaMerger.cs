using System;
using System.Collections.Generic;
using System.Linq;
using cts.commons.portable.Util;
using log4net;
using softwrench.sw4.Shared2.Metadata.Applications.Command;
using softwrench.sw4.Shared2.Metadata.Applications.Filter;
using softWrench.sW4.Exceptions;
using softwrench.sW4.Shared2.Metadata.Applications.Schema;
using softwrench.sw4.Shared2.Metadata.Applications.Schema;
using softwrench.sW4.Shared2.Metadata.Applications.Schema.Interfaces;
using softwrench.sw4.Shared2.Metadata.Applications.Schema.Interfaces;
using softwrench.sW4.Shared2.Metadata.Applications.Relationships.Associations;
using softwrench.sW4.Shared2.Util;
using softWrench.sW4.Metadata.Applications.Schema;

namespace softWrench.sW4.Metadata.Validator {
    class SchemaMerger {
        private const string NonCustomizableFound = "overriden schemas can only contain customizations, however found {0} wrong displayables ( {1}) for schema {2}";

        private static readonly ILog Log = LogManager.GetLogger(typeof(SchemaMerger));

        public static void MergeSchemas(ApplicationSchemaDefinition original, ApplicationSchemaDefinition overridenSchema, IEnumerable<DisplayableComponent> components) {

            var nonCustomizableDisplayables = GetNonCustomizableFields(overridenSchema);
            if (nonCustomizableDisplayables.Any()) {
                var names = new List<string>();
                foreach (var field in nonCustomizableDisplayables) {
                    var attrfield = field as IApplicationAttributeDisplayable;
                    if (attrfield != null) {
                        names.Add(attrfield.Attribute);
                    }
                }

                throw new MetadataException(NonCustomizableFound.Fmt(nonCustomizableDisplayables.Count(),
                    string.Join(",", names), overridenSchema));
            }
            var customizations = GetCustomizations(overridenSchema);
            var fieldsThatShouldBeCustomized = customizations.Count();
            var customizationsActuallyApplied = new HashSet<int>();
            original.Stereotype = overridenSchema.Stereotype == SchemaStereotype.None
                ? original.Stereotype
                : overridenSchema.Stereotype;
            original.CommandSchema.Merge(overridenSchema.CommandSchema);



            DoApplyCustomizations(original, overridenSchema, components, customizations, customizationsActuallyApplied, fieldsThatShouldBeCustomized);
            SchemaFilterBuilder.ApplyFilterCustomizations(original.SchemaFilters, overridenSchema.DeclaredFilters);
            original.MergeProperties(overridenSchema);
        }


        private static void DoApplyCustomizations(IApplicationDisplayableContainer original,
            ApplicationSchemaDefinition overridenSchema, IEnumerable<DisplayableComponent> components,
            IList<ApplicationSchemaCustomization> customizations, HashSet<int> customizationsActuallyApplied,
            int fieldsThatShouldBeCustomized) {
            var resultDisplayables = new List<IApplicationDisplayable>();
            foreach (var displayable in original.Displayables) {
                var attrDisplayablee = displayable as IApplicationIndentifiedDisplayable;
                if (attrDisplayablee == null || IsAutoGenerated(attrDisplayablee)) {
                    //can only replace fields that have attributes
                    //TODO: think of what to do with the hidden fields that were generated automatically on associations, and how to handle customizations on these.
                    resultDisplayables.Add(displayable);
                    continue;
                }
                if (displayable is IApplicationDisplayableContainer) {
                    //sections, tabs
                    DoApplyCustomizations((IApplicationDisplayableContainer)displayable,
                        overridenSchema, components,
                         customizations, customizationsActuallyApplied,
                        fieldsThatShouldBeCustomized);
                    resultDisplayables.Add(displayable);
                    continue;
                }

                var attribute = attrDisplayablee.Attribute;

                var customization =
                    customizations.FirstOrDefault(
                        f =>
                            (f.Position.Equals(attribute) || f.Position.Equals("+" + attribute) ||
                             f.Position.Equals("-" + attribute)));
                if (customization == null) {
                    if (displayable is ApplicationAssociationDefinition) {
                        //if the field is an association let´s give it a change to search for the label field instead before assuming there´s no customization present
                        //this is needed because sometimes we might have multiple fields pointing to a same target and would be preferable to use that strategy, otherwise
                        // both fields would be customized. See materials.xml
                        var association = displayable as ApplicationAssociationDefinition;
                        var labelField = association.OriginalLabelField;
                        customization =
                            customizations.FirstOrDefault(
                        f =>
                            (f.Position.Equals(labelField) || f.Position.Equals("+" + labelField) ||
                             f.Position.Equals("-" + labelField)));

                    }
                }

                if (customization == null) {
                    //no customization found, add the original field normally
                    resultDisplayables.Add(displayable);
                    continue;
                }

                Log.DebugFormat("applying customization {0} on schema {1}", customization.Position, overridenSchema);
                customizationsActuallyApplied.Add(customizations.IndexOf(customization));

                if (customization.Position.StartsWith("-")) {
                    if (!customization.Displayables.Any()) {
                        throw new MetadataException(
                            "left customizations must have a body, check your metadata at {0}  | customization: {1}".Fmt(
                                overridenSchema, customization.Position));
                    }
                    var resolvedDisplayables = DisplayableUtil.PerformReferenceReplacement(customization.Displayables,
                        overridenSchema, overridenSchema.ComponentDisplayableResolver, components);
                    resultDisplayables.AddRange(resolvedDisplayables);
                    resultDisplayables.Add(displayable);
                } else if (customization.Position.StartsWith("+")) {
                    if (!customization.Displayables.Any()) {
                        throw new MetadataException(
                            "right customizations must have a body, check your metadata at {0} | customization: {1}".Fmt(
                                overridenSchema, customization.Position));
                    }
                    resultDisplayables.Add(displayable);
                    var resolvedDisplayables = DisplayableUtil.PerformReferenceReplacement(customization.Displayables,
                        overridenSchema, overridenSchema.ComponentDisplayableResolver, components);
                    resultDisplayables.AddRange(resolvedDisplayables);
                } else {
                    //exact match
                    //if empty this would replace the existing displayable
                    var resolvedDisplayables = DisplayableUtil.PerformReferenceReplacement(customization.Displayables,
                        overridenSchema, overridenSchema.ComponentDisplayableResolver, components);
                    resultDisplayables.AddRange(resolvedDisplayables);
                }
            }
            if (customizationsActuallyApplied.Count != fieldsThatShouldBeCustomized && (original is ApplicationSchemaDefinition)) {
                //second condition means that this is not a section iteration, i.e --> check number just at the end
                var names = new List<string>();
                for (var i = 0; i < customizations.Count; i++) {
                    if (!customizationsActuallyApplied.Contains(i)) {
                        names.Add(customizations[i].Position);
                    }
                }
                throw new MetadataException(
                    "customizations {0} could not be applied cause the corresponding fields were not found in schema {1}".Fmt(
                        String.Join(",", names), overridenSchema));
            }
            original.Displayables = resultDisplayables;
        }

        private static bool IsAutoGenerated(IApplicationIndentifiedDisplayable attrDisplayablee) {
            var fieldDef = attrDisplayablee as ApplicationFieldDefinition;
            return fieldDef != null && fieldDef.AutoGenerated;
        }

        private static IApplicationDisplayable[] GetNonCustomizableFields(ApplicationSchemaDefinition overridenSchema) {
            var result = overridenSchema.Displayables.Where(disp => !(disp is ApplicationSchemaCustomization)).Where(disp => !(disp is ApplicationFieldDefinition) || !((ApplicationFieldDefinition)disp).AutoGenerated).ToList();
            return result.ToArray();
        }

        private static IList<ApplicationSchemaCustomization> GetCustomizations(ApplicationSchemaDefinition overridenSchema) {
            return DisplayableUtil.GetDisplayable<ApplicationSchemaCustomization>(typeof(ApplicationSchemaCustomization), overridenSchema.Displayables);
        }

        public static bool IsCustomized(ApplicationSchemaDefinition overridenSchema) {
            return GetCustomizations(overridenSchema).Count > 0;
        }
    }
}
