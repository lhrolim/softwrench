using System.Collections.Generic;
using System.Linq;
using DocumentFormat.OpenXml.Spreadsheet;
using JetBrains.Annotations;
using softWrench.sW4.Metadata.Entities.Connectors;
using softWrench.sW4.Util;
using System;

namespace softWrench.sW4.Metadata.Entities.Schema {
    public class EntityAttribute {
        public const string AttributeQualifierSeparator = ".";

        private readonly string _name;
        private readonly string _type;
        private readonly bool _isRequired;
        private readonly ConnectorParameters _connectorParameters;
        private readonly bool _isAutoGenerated;
        public bool IgnoreCoalesce { get; set; }

        public EntityAttribute([NotNull] string name, [NotNull] string type, bool isRequired, bool isAutoGenerated, [NotNull] ConnectorParameters connectorParameters, string query) {
            Validate.NotNull(name, "name");
            Validate.NotNull(type, "type");
            Validate.NotNull(connectorParameters, "connectorParameters");

            _name = name;
            _type = type;
            Query = query;
            _isRequired = isRequired;
            _connectorParameters = connectorParameters;
            _isAutoGenerated = isAutoGenerated;
            IgnoreCoalesce = false;
        }

        [NotNull]
        public string Name {
            get {
                return _name;
            }
        }

        [NotNull]
        public string Type {
            get {
                return _type;
            }
        }


        public bool IsRequired {
            get {
                return _isRequired;
            }
        }

        public string Query {
            get; set;
        }

        [NotNull]
        public ConnectorParameters ConnectorParameters {
            get {
                return _connectorParameters;
            }
        }

        public bool IsAutoGenerated {
            get {
                return _isAutoGenerated;
            }
        }

        public bool IsAssociated {
            get {
                return _name.Contains(AttributeQualifierSeparator);
            }
        }

        public bool IsDate {
            get {
                return Type == "timestamp" || Type == "datetime";
            }
        }

        public bool IsNumber {
            get {
                return Type == "int" || Type == "bigint" || Type == "float" || Type == "integer" || Type == "decimal";
            }
        }

        public override string ToString() {
            return string.Format("Name: {0}, Type: {1}", _name, _type);
        }

        protected bool Equals(EntityAttribute other) {
            return string.Equals(_name, other._name);
        }

        public override bool Equals(object obj) {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((EntityAttribute)obj);
        }

        public override int GetHashCode() {
            return (_name != null ? _name.GetHashCode() : 0);
        }

        public virtual string GetQueryReplacingMarkers(String entityName) {
            if (Query.StartsWith("ref:")) {
                Query = MetadataProvider.EntityQuery(Query);
                if (Query.StartsWith("#ic")) {
                    IgnoreCoalesce = true;
                    Query = Query.Substring(3);
                }
            }
            return Query.Replace("!@", entityName + ".");
        }

        public EntityAttribute ClonePrependingContext(string context) {
            var contextSegments = EntityUtil.GetRelationshipParts(context);
            var nameSegments = EntityUtil.GetRelationshipParts(Name);
            var resultName = Name;
            if (!ShouldMerge(contextSegments, nameSegments)) {

                if (!nameSegments.Any()) {
                    resultName = "." + resultName;
                }
                return new ContextualEntityAttribute(context + resultName, Type, IsRequired,
                IsAutoGenerated, ConnectorParameters, Query, context);
            }
            foreach (var nameSegment in nameSegments) {
                contextSegments.Add(nameSegment);
            }
            context = string.Join("_", contextSegments) + "_";
            resultName = EntityUtil.GetAttributeName(Name);
            return new ContextualEntityAttribute(context + "." + resultName, Type, IsRequired,
                IsAutoGenerated, ConnectorParameters, Query, context);
        }

        private static bool ShouldMerge(ISet<string> contextSegments, ISet<string> nameSegments) {
            var any = contextSegments.Any() && nameSegments.Any();
            if (!any) {
                return false;
            }
            return nameSegments.Any(contextSegments.Contains);
        }
    }
}