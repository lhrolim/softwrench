<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://www.w3.org/2001/XMLSchema"
	targetNamespace="http://www.controltechnologysolutions.com/metadata"
	xmlns:tns="http://www.controltechnologysolutions.com/metadata"
	elementFormDefault="qualified"
	xmlns:pref="http://www.controltechnologysolutions.com/menumetadata"
	xmlns:f="http://www.controltechnologysolutions.com/filters"
	xmlns:s="http://www.controltechnologysolutions.com/stereotypes">


  <import schemaLocation="filters.xsd"
		namespace="http://www.controltechnologysolutions.com/filters">
  </import>
  <import schemaLocation="stereotypes.xsd" namespace="http://www.controltechnologysolutions.com/stereotypes"></import>


  <element name="metadata">
    <complexType>
      <choice minOccurs="0" maxOccurs="unbounded">
        <element name="entities" type="tns:Entities"
					maxOccurs="1" minOccurs="1">
        </element>
        <element name="applications" type="tns:Applications"
					maxOccurs="1" minOccurs="1">
        </element>
        <element name="templates" type="tns:TemplatesType"></element>
        <element name="commandbars"
					type="tns:CommandsDeclarationsType">
        </element>
        <element name="stereotypes" type="s:stereotypes"></element>
      </choice>
    </complexType>
  </element>

  <complexType name="Metadata"></complexType>

  <complexType name="Entities">
    <choice minOccurs="0" maxOccurs="unbounded">
      <element name="queries" type="tns:queriesType" minOccurs="0"
				maxOccurs="1">
      </element>
      <element name="entity" type="tns:Entity"
				maxOccurs="unbounded" minOccurs="1">
      </element>
    </choice>
  </complexType>

  <complexType name="CommandsDeclarationsType">
    <choice minOccurs="0" maxOccurs="unbounded">
      <element name="commandgroup" type="tns:commandsComplexType"
				minOccurs="0" maxOccurs="unbounded">
      </element>
    </choice>
  </complexType>

  <complexType name="TemplatesType">

    <choice>
      <element name="template" maxOccurs="unbounded"
				minOccurs="1">
        <complexType>
          <attribute name="path" type="string"></attribute>
        </complexType>
      </element>
    </choice>
  </complexType>

  <complexType name="Applications">
    <sequence>
      <element name="application" type="tns:Application"
				maxOccurs="unbounded" minOccurs="1">
      </element>
    </sequence>
  </complexType>

  <complexType name="Entity">
    <sequence>
      <element name="attributes" maxOccurs="1" minOccurs="0">
        <complexType>
          <sequence>
            <element name="attribute" type="tns:Attribute"
							maxOccurs="unbounded" minOccurs="1">
            </element>
          </sequence>
          <attribute name="excludeundeclared"
						type="boolean">
          </attribute>
        </complexType>
      </element>
      <element name="relationships" maxOccurs="1" minOccurs="0">
        <complexType>
          <sequence>
            <element name="relationship"
							type="tns:Relationship" maxOccurs="unbounded" minOccurs="1">
            </element>
          </sequence>
          <attribute name="excludeundeclared"
						type="boolean">
          </attribute>
        </complexType>
      </element>
      <element name="connectorParameters" maxOccurs="1"
				minOccurs="0">
        <complexType>
          <sequence>
            <element name="connectorParameter"
							type="tns:Parameter" maxOccurs="unbounded" minOccurs="1">
            </element>
          </sequence>
          <attribute name="excludeundeclared"
						type="boolean">
          </attribute>
        </complexType>
      </element>
    </sequence>
    <attribute name="name" type="string" use="required"></attribute>
    <attribute name="idAttribute" type="string" use="required"></attribute>
    <attribute name="useridAttribute" type="string"
			use="optional">
      <annotation>
        <documentation>
          this id is the one which the user uses to refer to
          the entity, therefore it would be seen on the
          screens, as opposite to the idattribute which stands
          only for the database pk
        </documentation>
      </annotation>

    </attribute>
    <attribute name="whereclause" type="string"></attribute>
    <attribute name="parententity" type="string"></attribute>
  </complexType>

  <complexType name="Attribute">
    <attribute name="name" type="string" use="required"></attribute>
    <attribute name="required" type="string"></attribute>
    <attribute name="type" type="string" use="required"></attribute>
    <attribute name="auto-generated" type="boolean"></attribute>
    <attribute name="query" type="string">
      <annotation>
        <documentation>
          a query will be executed when a declared application
          asks for this attribute.

          Remarks:

          1) use !@ chars to make framework replace the
          correct current entity name, considering join
          contexts

          2) use ref:xxx to refer to a declared global query
          named xxx

          3) use @xxx.yyy to refer to a injectable service xxx
          and method yyy that should return the query at
          runtime
        </documentation>
      </annotation>
    </attribute>
  </complexType>

  <complexType name="Relationship">
    <sequence>
      <element name="relationshipAttribute"
				type="tns:RelationshipAttribute" maxOccurs="unbounded"
				minOccurs="1">
      </element>
    </sequence>
    <attribute name="to" type="string"></attribute>
    <attribute name="collection" type="boolean" default="false"></attribute>
    <attribute name="qualifier" type="string" />
    <attribute name="lazy" type="boolean" />
    <attribute name="cacheable" type="boolean">
      <annotation>
        <documentation>
          if true, this will instruct the framework to cache
          the complete list of elements to be later retrieved.

          This should be used only on maximo config entries,
          which are not subject to constant change, such as
          srstatus, wostatus, siteids, etc
        </documentation>
      </annotation>
    </attribute>
    <attribute name="reverselookupattribute" type="string">
      <annotation>
        <documentation>
          if this attribute is filled specifies that this is a
          reverse relationship, and that this attribute should
          be used as the association value, instead of the
          primary attribute. the primary relationship would
          still be used to set the initial value of the main
          entity
        </documentation>
      </annotation>
    </attribute>
    <attribute name="ignoreprimary" type="boolean">
      <annotation>
        <documentation>
          If the association doesn´t contain a primary
          attribute this should be marked explicitely as true.
          95% of the relationships contains primary
          attributes, so it´s good to have a validation
        </documentation>
      </annotation>
    </attribute>
  </complexType>

  <complexType name="RelationshipAttribute">
    <attribute name="from" type="string"></attribute>
    <attribute name="to" type="string"></attribute>
    <attribute name="primary" type="boolean"></attribute>
    <attribute name="literal" type="string"></attribute>
    <attribute name="query" type="string"></attribute>
    <attribute name="quoteLiteral" type="boolean"></attribute>
    <attribute name="allowsnull" type="boolean">
      <annotation>
        <documentation>
          If true, then a is null condition will be appended
          to the query. ex: (xxx.to = yyy)

          would become

          (xxx.to is null or xxx.to = yyy)
        </documentation>
      </annotation>
    </attribute>
  </complexType>

  <complexType name="Parameter">
    <attribute name="key" type="string" use="required"></attribute>
    <attribute name="value" type="string" use="required"></attribute>
  </complexType>

  <complexType name="Application">
    <choice minOccurs="0" maxOccurs="unbounded">
      <element name="schemas" maxOccurs="1" minOccurs="1">
        <complexType>
          <choice minOccurs="0" maxOccurs="unbounded">
            <element name="schema" type="tns:Schema"
							maxOccurs="unbounded" minOccurs="1">
            </element>
            <element name="detail" type="tns:Detail"></element>
            <element name="list" type="tns:List"></element>
          </choice>

        </complexType>
      </element>
      <element name="properties" maxOccurs="1" minOccurs="0">
        <complexType>
          <sequence>
            <element name="property" type="tns:Parameter"
							maxOccurs="unbounded" minOccurs="1">
            </element>
          </sequence>
        </complexType>
      </element>
      <element name="components" type="tns:displayablesType"
				minOccurs="0" maxOccurs="1">
      </element>
      <element name="filters" type="tns:FiltersDeclarationType"
				maxOccurs="1" minOccurs="0">
      </element>
    </choice>
    <attribute name="name" type="string" use="required"></attribute>
    <attribute name="title" type="string" use="required"></attribute>
    <attribute name="audit" type="boolean" use="optional"
			default="false">
    </attribute>
    <attribute name="entity" type="string" use="required"></attribute>
    <attribute name="id" type="string"></attribute>
    <attribute name="service" type="string"></attribute>
    <attribute name="role" type="string"></attribute>
  </complexType>

  <complexType name="Schema">
    <annotation>
      <documentation>
        Defines which schema should be renderized after this
        schema. If absent, the next schema will be choosen based
        on the stereotype rules, if any
      </documentation>
    </annotation>
    <complexContent>
      <extension base="tns:SchemaRequest">
        <choice minOccurs="0" maxOccurs="unbounded">
          <element name="field" type="tns:Field"
						maxOccurs="unbounded" minOccurs="0">
          </element>
          <element maxOccurs="unbounded" minOccurs="0"
						ref="tns:section">

          </element>
          <element name="association" type="tns:Association"
						maxOccurs="unbounded" minOccurs="0">
          </element>
          <element name="composition" type="tns:Composition"
						maxOccurs="unbounded" minOccurs="0">
          </element>
          <element name="optionfield" type="tns:OptionField"
						maxOccurs="unbounded" minOccurs="0">
          </element>
          <element name="properties" maxOccurs="unbounded"
						minOccurs="0">
            <complexType>
              <sequence>
                <element name="property"
									type="tns:Parameter" maxOccurs="unbounded" minOccurs="1">
                </element>
              </sequence>
            </complexType>
          </element>
          <element maxOccurs="unbounded" minOccurs="0"
						ref="tns:commands">

          </element>
          <element name="tab" type="tns:TabType"
						minOccurs="0">

          </element>
          <element name="commandbars" maxOccurs="unbounded"
						minOccurs="0" type="tns:CommandsDeclarationsType" />
          <element name="reference" minOccurs="0"
						maxOccurs="unbounded" type="tns:referenceComplexType">
          </element>
          <element name="event" type="tns:schemaEvent"
						minOccurs="0" maxOccurs="unbounded">
          </element>
          <element name="customization"
						type="tns:CustomizationType" minOccurs="0"
						maxOccurs="unbounded">
          </element>

          <element name="filters"
						type="tns:FiltersDeclarationType" maxOccurs="1" minOccurs="0">
          </element>
        </choice>
        <attribute name="platform" type="string"
					use="optional">
        </attribute>
        <attribute name="unionschema" type="string"
					use="optional" />
        <attribute name="stereotype"
					type="tns:StereotypeType">
          <annotation>
            <documentation>
              Indicates whether the schema should behave
              in a similar way to either a list or detail
              schemas. It´s a hint for the framework to
              know how to do proper optimization
            </documentation>
          </annotation>
        </attribute>
        <attribute name="title" type="string"></attribute>
        <attribute name="abstract" type="boolean"></attribute>
        <attribute name="parentschema" type="string"></attribute>
        <attribute name="redeclaring" type="string"
					use="optional" default="false">
          <annotation>
            <documentation>
              If true, it means that we should disconsider
              any schema declared with the same name on
              the templates file and use only this schema
              declaration.
            </documentation>
          </annotation>

        </attribute>

      </extension>
    </complexContent>
  </complexType>

  <complexType name="FiltersDeclarationType">
    <choice minOccurs="0" maxOccurs="unbounded">
      <element name="optionfilter" type="f:OptionFilterType"
				minOccurs="0" maxOccurs="unbounded">
      </element>
      <element name="booleanfilter" type="f:BoolFilterType"
				minOccurs="0" maxOccurs="unbounded">
      </element>
      <element name="datefilter" type="f:DateFilterType"
				minOccurs="0" maxOccurs="unbounded">
      </element>
      <element name="numericfilter" type="f:NumberFilterType"
				minOccurs="0" maxOccurs="unbounded">
      </element>
      <element name="modalfilter" type="f:ModalFilterType"
				minOccurs="0" maxOccurs="unbounded">
      </element>
      <element name="filter" type="f:BaseFilterType" minOccurs="0"
				maxOccurs="unbounded">
      </element>
    </choice>
    <attribute name="removeundeclared" type="boolean"></attribute>
  </complexType>


  <complexType name="CustomizationType">
    <annotation>
      <documentation>
        Used for modifying the base template on a given
        position, adding or removing fields for a customer. Ex:
        customer xxx wants to use workorder template, modifying
        just a field of a schema. Then, he would need to
        redeclare the schema with the same key and a
        customization on it with the fields (or empty to
        replace)

        One single redeclared schema could contain several
        customizations in place.
      </documentation>
    </annotation>

    <choice minOccurs="0" maxOccurs="unbounded">
      <element name="field" type="tns:Field" maxOccurs="unbounded"
				minOccurs="0">
      </element>
      <element maxOccurs="unbounded" minOccurs="0"
				ref="tns:section" />
      <element name="association" type="tns:Association"
				maxOccurs="unbounded" minOccurs="0">
      </element>
      <element name="composition" type="tns:Composition"
				maxOccurs="unbounded" minOccurs="0">
      </element>
      <element name="optionfield" type="tns:OptionField"
				maxOccurs="unbounded" minOccurs="0">
      </element>
      <element name="tab" type="tns:TabType" minOccurs="0" />
      <element name="reference" minOccurs="0"
				maxOccurs="unbounded" type="tns:referenceComplexType" />
    </choice>

    <attribute name="position" type="string" use="required">
      <annotation>
        <documentation>
          Indicates where to insert a this customization.

          xxx --> replaces element with id xxx (attribute or
          target) with the customization. If the customization
          body is empty, then removes the element +xxx -->
          inserts the customization after the element xxx.
          -xxx --> inserts the customization before the
          element xxx

          In any case, if xxx is not found throw an exception

        </documentation>
      </annotation>
    </attribute>

  </complexType>


  <simpleType name="modeType">
    <restriction base="string">
      <enumeration value="input"></enumeration>
      <enumeration value="output"></enumeration>
    </restriction>
  </simpleType>

  <complexType name="Field">
    <choice minOccurs="0" maxOccurs="unbounded">
      <element name="renderer" type="tns:Renderer" maxOccurs="1"
				minOccurs="0">
      </element>
      <element name="filter" type="tns:Filter" maxOccurs="1"
				minOccurs="0">
      </element>
      <element name="number" maxOccurs="1" minOccurs="0">
        <complexType>
          <attribute name="decimals" type="int"></attribute>
          <attribute name="min" type="int"></attribute>
          <attribute name="max" type="int"></attribute>
        </complexType>
      </element>
      <element name="lookup" type="tns:Lookup" maxOccurs="1"
				minOccurs="0">
      </element>
      <element name="date" maxOccurs="1" minOccurs="0">
        <complexType>
          <attribute name="format" type="string"></attribute>
          <attribute name="time" type="boolean"></attribute>
        </complexType>
      </element>
      <element name="event" type="tns:inputEvent" minOccurs="0"
				maxOccurs="unbounded">
      </element>
    </choice>

    <attribute name="attribute" type="string"></attribute>
    <attribute name="attributeToServer" type="string">
      <annotation>
        <documentation>
          Attribute name to be sent to server API controller,
          via json
        </documentation>
      </annotation>
    </attribute>
    <attribute name="label" type="string"></attribute>
    <attribute name="requiredexpression" type="string"></attribute>
    <attribute name="readonly" type="boolean"></attribute>
    <attribute name="hidden" type="boolean"></attribute>
    <attribute name="showexpression" type="string"></attribute>
    <attribute name="enableexpression" type="string"></attribute>
    <attribute name="evalexpression" type="string"></attribute>
    <attribute name="qualifier" type="string"></attribute>
    <attribute name="default" type="string"></attribute>
    <attribute name="defaultexpression" type="string"></attribute>
    <attribute name="tooltip" type="string"></attribute>
    <attribute name="preventnoresultscarry" type="boolean">
      <annotation>
        <documentation>
          During a search of no results a creation can be started.
          If this atribute is set to true no search data of this field will be carried.
        </documentation>
      </annotation>
    </attribute>
  </complexType>

  <complexType name="Renderer">
    <attribute name="type" type="string" use="required"></attribute>
    <attribute name="params" type="string"></attribute>
    <attribute name="stereotype" type="string"></attribute>
  </complexType>

  <complexType name="Filter">
    <attribute name="operation" type="string"></attribute>
    <attribute name="params" type="string"></attribute>
    <attribute name="default" type="string"></attribute>
    <attribute name="clientfunction" type="string"></attribute>
  </complexType>

  <complexType name="Lookup">
    <sequence>
      <element name="lookupFilters" type="tns:LookupFilters"
				maxOccurs="1" minOccurs="0">
      </element>
    </sequence>
    <attribute name="sourceApplication" type="string"></attribute>
    <attribute name="sourceField" type="string"></attribute>
    <attribute name="sourceDisplay" type="string"></attribute>
    <attribute name="targetField" type="string"></attribute>
    <attribute name="targetQualifier" type="string"></attribute>
  </complexType>

  <complexType name="LookupFilters">
    <sequence>
      <element name="lookupFilter" type="tns:LookupFilter"
				maxOccurs="unbounded" minOccurs="0">
      </element>
    </sequence>
  </complexType>

  <complexType name="LookupFilter">
    <attribute name="sourceField" type="string"></attribute>
    <attribute name="literal" type="string"></attribute>
    <attribute name="targetField" type="string"></attribute>
  </complexType>

  <complexType name="Association">
    <choice minOccurs="0" maxOccurs="unbounded">
      <element name="dataprovider" type="tns:DataProvider"
				maxOccurs="1" minOccurs="0">
      </element>
      <element name="renderer" type="tns:Renderer" maxOccurs="1"
				minOccurs="0">
      </element>
      <element name="filter" type="tns:Filter" maxOccurs="1"
				minOccurs="0">
      </element>
      <element name="event" type="tns:inputEvent" minOccurs="0"
				maxOccurs="unbounded">
      </element>
      <element name="details" type="tns:sectionComplexType"
				maxOccurs="1" minOccurs="0">
      </element>
    </choice>

    <attribute name="label" type="string" use="required"></attribute>
    <attribute name="target" type="string" use="required">
      <annotation>
        <documentation>
          The name of the datamap property to which the
          selected value will be setted. This will be passed
          to the server on the json string
        </documentation>
      </annotation>
    </attribute>
    <attribute name="labelfield" type="string" use="required">
      <annotation>
        <documentation>
          should be a pattern like x_.y where x_ is the name
          of the relationship and y is the column to use as
          the label field.
        </documentation>
      </annotation>
    </attribute>
    <attribute name="valuefield" type="string" use="optional">
      <annotation>
        <documentation>
          The name of the property (column) that should be
          used for picking up the value of the association
          entry. That value would then be inserted into the
          datamap[target] field. If none provided, then the
          framework would use the primary key of the entity
          relationship as the value column
        </documentation>
      </annotation>
    </attribute>
    <attribute name="default" type="string"></attribute>
    <attribute name="defaultexpression" type="string"></attribute>
    <attribute name="labelpattern" type="string"></attribute>
    <attribute name="placeholder" type="string"></attribute>
    <attribute name="extraprojectionvalues" type="string"
			use="optional">
      <annotation>
        <documentation>
          Comma separeted list of extra fields to be fetched
          from the relationship besides the target and label
          ones. Those fields will be available to the
          application for read-only use, and shall not be
          submited back to the server.
          <br />

          If you need to submit such values to server side,
          use a hidden field
          <br />

          The column is related to the to relationship (so if
          labelfield = a_.b you could use any value of a_
          relationship).
          <br />

        </documentation>
      </annotation>
    </attribute>
    <attribute name="showexpression" type="string"></attribute>
    <attribute name="dependantfields" type="string"></attribute>
    <attribute name="tooltip" type="string"></attribute>
    <attribute name="enableexpression" type="string"
			use="optional">
    </attribute>
    <attribute name="forcedistinctoptions" type="boolean"
			use="optional">
    </attribute>
    <attribute name="requiredexpression" type="string"></attribute>
    <attribute name="qualifier" type="string"></attribute>
    <attribute name="hideDescription" type="boolean"></attribute>
    <attribute name="orderbyfield" type="string" use="optional">
      <annotation>
        <documentation>
          Specify the attribute to sort the search result by.
        </documentation>
      </annotation>
    </attribute>
  </complexType>

  <complexType name="DataProvider">
    <attribute name="postfilterfunction" type="string"></attribute>
    <attribute name="whereClause" type="string"></attribute>
    <attribute name="prefilterfunction" type="string"></attribute>
    <attribute name="method" type="string"></attribute>
  </complexType>

  <complexType name="AssociationDetail">
    <attribute name="showexpression" type="string"></attribute>
  </complexType>

  <complexType name="Composition">
    <sequence>

      <element name="header" type="tns:headerType" minOccurs="0"
				maxOccurs="1">
      </element>

      <choice minOccurs="0" maxOccurs="unbounded">
        <element name="renderer" type="tns:Renderer"
					maxOccurs="1" minOccurs="0">
        </element>
        <element name="collectionproperties" maxOccurs="1"
					minOccurs="0">
          <complexType>
            <attribute name="allowremoval" type="string"
							default="false">
            </attribute>
            <attribute name="allowupdate" type="string"
							default="false">
            </attribute>
            <attribute name="allowcreation" type="string"
							default="true">
            </attribute>
            <attribute name="listschema" type="string"></attribute>
            <attribute name="autocommit" type="boolean"
							use="optional" />
            <attribute name="hideexistingdata"
							type="boolean" use="optional" />
            <attribute name="orderbyfield" type="string"
							use="optional" />
            <attribute name="prefilterfunction"
							type="string" use="optional" />
            <attribute name="printenabled" type="boolean"
							use="optional">
              <annotation>
                <documentation>
                  Enable/disable the print section.
                </documentation>
              </annotation>
            </attribute>
          </complexType>
        </element>
        <element name="event" type="tns:schemaEvent"
					minOccurs="0" maxOccurs="unbounded">
        </element>
      </choice>
    </sequence>
    <attribute name="relationship" type="string" use="required"></attribute>
    <attribute name="label" type="string" use="required"></attribute>
    <attribute name="inline" type="boolean" default="true"></attribute>
    <attribute name="hidden" type="boolean"></attribute>
    <attribute name="fetchtype" type="tns:FetchType" />
    <attribute name="detailschema" type="string">
      <annotation>
        <documentation>
          The schema which will be used on the composition. If
          none is provided, "detail" will be used as a default
        </documentation>
      </annotation>
    </attribute>
    <attribute name="printschema" type="string">
      <annotation>
        <documentation>
          The schema which will be used for printing the
          composition. If none is provided, "detail" will be
          used as a default
        </documentation>
      </annotation>
    </attribute>
    <attribute name="rendermode" type="tns:NewSimpleType"
			use="optional">
      <annotation>
        <documentation>
          If absent the composition will be rendered on the
          same type as the root entity (like input --&gt;
          input). Use this to fix the composition on input
          mode even if the root entity is on output mode
        </documentation>
      </annotation>
    </attribute>
    <attribute name="showexpression" type="string"></attribute>
    <attribute name="tooltip" type="string"></attribute>
  </complexType>

  <complexType name="OptionField">
    <sequence>
      <element name="renderer" type="tns:Renderer" maxOccurs="1"
				minOccurs="0">
      </element>
      <element name="filter" type="tns:Filter" maxOccurs="1"
				minOccurs="0">
      </element>
      <element name="option" type="tns:OptionType"
				maxOccurs="unbounded" minOccurs="0">
      </element>
      <element name="event" type="tns:inputEvent" minOccurs="0"
				maxOccurs="unbounded">
      </element>
    </sequence>
    <attribute name="label" type="string"></attribute>
    <attribute name="attribute" type="string" use="required"></attribute>
    <attribute name="requiredexpression" type="string"></attribute>
    <attribute name="default" type="string"></attribute>
    <attribute name="defaultexpression" type="string"></attribute>
    <attribute name="showexpression" type="string"></attribute>
    <attribute name="evalexpression" type="string"></attribute>
    <attribute name="tooltip" type="string"></attribute>

    <attribute name="providerattribute" type="string"
			use="optional">
      <annotation>
        <documentation>
          If this attribute is present the list will be
          fetched from this value instead of predefined on the
          metadata
        </documentation>
      </annotation>
    </attribute>
    <attribute name="extraparameter" type="string" use="optional">
      <annotation>
        <documentation>
          Use this attribute only if providerattribute is
          used. This will provide addition input parameter if
          needed.
        </documentation>
      </annotation>
    </attribute>
    <attribute name="sort" type="boolean"></attribute>
    <attribute name="dependantfields" type="string"></attribute>
    <attribute name="qualifier" type="string"></attribute>
    <attribute name="skipvalidation" type="boolean">
      <annotation>
        <documentation>
          If true skips the validation of "provideratribute" attribute.
        </documentation>
      </annotation>
    </attribute>
  </complexType>

  <complexType name="OptionType">
    <attribute name="label" type="string" use="required"></attribute>
    <attribute name="value" type="string" use="required"></attribute>
  </complexType>


  <complexType name="ConnectorParameter"></complexType>

  <complexType name="Detail">
    <complexContent>
      <extension base="tns:Schema">
        <attribute name="id" type="string" use="optional" />
      </extension>
    </complexContent>
  </complexType>

  <complexType name="List">
    <complexContent>
      <extension base="tns:Schema">
        <attribute name="id" type="string" use="optional"></attribute>
      </extension>
    </complexContent>
  </complexType>

  <simpleType name="FetchType">
    <restriction base="string">
      <enumeration value="eager"></enumeration>
      <enumeration value="lazy"></enumeration>
      <enumeration value="manual"></enumeration>
    </restriction>
  </simpleType>

  <simpleType name="StereotypeType">
    <restriction base="string">
      <enumeration value="list"></enumeration>
      <enumeration value="detail"></enumeration>
      <enumeration value="detailnew"></enumeration>
      <enumeration value="compositionlist"></enumeration>
      <enumeration value="compositiondetail"></enumeration>
      <enumeration value="detail.modal"></enumeration>
    </restriction>
  </simpleType>

  <simpleType name="SchemaModeType">
    <restriction base="string">
      <enumeration value="input"></enumeration>
      <enumeration value="output"></enumeration>
    </restriction>
  </simpleType>

  <complexType name="SchemaRequest">
    <attribute name="id" type="string"></attribute>
    <attribute name="mode" type="string"></attribute>
  </complexType>

  <complexType name="Command">
    <attribute name="id" type="string" use="required"></attribute>
    <attribute name="label" type="string" use="optional"></attribute>
    <attribute name="tooltip" type="string"></attribute>
    <attribute name="service" type="string"></attribute>
    <attribute name="method" type="string"></attribute>
    <attribute name="parameters" type="string" use="optional">
      <annotation>
        <documentation>
          comma separeted list of parameter names of the
          $scope variable to pass through the command
        </documentation>
      </annotation>
    </attribute>
    <attribute name="properties" type="string" use="optional">
      <annotation>
        <documentation>
          extra properties of the command, not related to the
          invocation per si, like a class for instance
        </documentation>
      </annotation>
    </attribute>
    <attribute name="showexpression" type="string"></attribute>
    <attribute name="enableexpression" type="string"></attribute>
    <attribute name="role" type="string" use="optional"></attribute>
    <attribute name="stereotype">
      <simpleType>
        <restriction base="string">
          <enumeration value="print"></enumeration>
          <enumeration value="confirm"></enumeration>
          <enumeration value="cancel"></enumeration>
          <enumeration value="delete"></enumeration>
          <enumeration value="modal"></enumeration>
          <enumeration value="redirection"></enumeration>
        </restriction>
      </simpleType>
    </attribute>
    <attribute name="remove" type="boolean">
      <annotation>
        <documentation>
          Specifies whether this declaration is to remove an
          available command (true), or to add a new one
        </documentation>
      </annotation>
    </attribute>
    <attribute name="successmessage" type="string"
			default="data successfully saved">
    </attribute>
    <attribute name="cssclasses" type="string"></attribute>
    <attribute name="primary" type="boolean"></attribute>
    <attribute name="nextSchemaId" type="string"></attribute>


    <attribute name="position">
      <annotation>
        <documentation>
          comma separeted list of parameter names of the
          $scope variable to pass through the command
        </documentation>
      </annotation>
    </attribute>
    <attribute name="icon" type="string"></attribute>

    <attribute name="defaultposition">
      <simpleType>
        <restriction base="string">
          <enumeration value="left"></enumeration>
          <enumeration value="right"></enumeration>
        </restriction>
      </simpleType>
    </attribute>
  </complexType>

  <complexType name="ToggleCommand">
    <annotation>
      <documentation>
        A command with two states on and off. Needs two children commands: <br/>
        &lt;oncommand&gt; the command when the toggle is in on state. <br/>
        &lt;offcommand&gt; the command when the toggle is in off state.
      </documentation>
    </annotation>
    <choice minOccurs="2" maxOccurs="2">
      <element minOccurs="1" maxOccurs="1" name="oncommand" type="tns:Command"/>
      <element minOccurs="1" maxOccurs="1" name="offcommand" type="tns:Command"/>
    </choice>
    <attribute name="id" type="string"></attribute>
    <attribute name="initialstateexpression" type="string">
      <annotation>
        <documentation>
          Expression to decide the initial state of the toggle button.
          A result of "true" for on state, anything else for off state.
          It could be a java script expression or "$scope:aFunction" to ref a function of
          the toolbar parent controller.
        </documentation>
      </annotation>
    </attribute>
    <attribute name="position" type="string">
      <annotation>
        <documentation>
          The position will inform where to place the command,
          relative to another command present on the default
          command bar.

          It should have the syntax:

          * C1 --&gt; gruop this command with existing command
          C1 * &gt;C1--&gt; place this command right to the
          command C1 * &amp;lt;C1 --&gt; place this command left
          to the command C1

          If none provided, the command will be placed at the
          end of the bar.

          Note, inside a &quot;commands&quot; declaration the
          order should be set declaratively, by the order of the
          children



          besides, as a legacy mode, it accepts values left or
          right to place the command relatively to the default
          commands on screen
        </documentation>
      </annotation>
    </attribute>
  </complexType>
  
  <simpleType name="NewSimpleType">
    <restriction base="string">
      <enumeration value="input"></enumeration>
      <enumeration value="output"></enumeration>
    </restriction>
  </simpleType>

  <complexType name="Environment">
    <choice minOccurs="0" maxOccurs="unbounded">
      <element name="property" type="tns:Parameter"></element>
    </choice>
    <attribute name="key" type="string" use="required" />
  </complexType>

  <complexType name="TabType">



    <annotation>
      <documentation>
        This element will render a new tab, just like the
        compositions, but the only difference is that it doesn´t
        refer to any entity.

        Inside a tab, any displayable could be inserted.
      </documentation>
    </annotation>
    <choice minOccurs="0" maxOccurs="unbounded">
      <element name="field" type="tns:Field" maxOccurs="unbounded"
				minOccurs="0">
      </element>
      <element name="association" type="tns:Association"
				maxOccurs="unbounded" minOccurs="0">
      </element>
      <element name="composition" type="tns:Composition"
				maxOccurs="unbounded" minOccurs="0">
      </element>
      <element name="optionfield" type="tns:OptionField"
				maxOccurs="unbounded" minOccurs="0">
      </element>
      <element name="section" type="tns:sectionComplexType"
				minOccurs="0" maxOccurs="unbounded">
      </element>
    </choice>
    <attribute name="id" type="string"></attribute>
    <attribute name="showexpression" type="string"></attribute>
    <attribute name="tooltip" type="string"></attribute>
    <attribute name="label" type="string"></attribute>
    <attribute name="icon" type="string"></attribute>
    <attribute name="role" type="string"></attribute>


  </complexType>
  <element name="section" type="tns:sectionComplexType"></element>
  <complexType name="sectionComplexType">
    <sequence>
      <element name="header" type="tns:headerType" minOccurs="0"
				maxOccurs="1">
      </element>
      <element name="renderer" type="tns:Renderer" maxOccurs="1"
				minOccurs="0">
      </element>
      <choice minOccurs="0" maxOccurs="unbounded">
        <element minOccurs="0" maxOccurs="unbounded"
					name="field" type="tns:Field">
        </element>
        <element minOccurs="0" maxOccurs="unbounded"
					name="association" type="tns:Association">
        </element>
        <element minOccurs="0" maxOccurs="unbounded"
					name="composition" type="tns:Composition">
        </element>
        <element minOccurs="0" maxOccurs="unbounded"
					name="optionfield" type="tns:OptionField">
        </element>
        <element name="section" type="tns:sectionComplexType"
					minOccurs="0" maxOccurs="unbounded">
        </element>
        <element name="reference"
					type="tns:referenceComplexType" minOccurs="0"
					maxOccurs="unbounded">
        </element>
      </choice>
    </sequence>
    <attribute name="id" type="string"></attribute>
    <attribute name="resourcepath" type="string">
      <annotation></annotation>
    </attribute>
    <attribute name="parameters" type="string"></attribute>

    <attribute name="attribute" type="string"></attribute>
    <attribute name="showexpression" type="string"></attribute>
    <attribute name="orientation" default="vertical">
      <annotation>
        <documentation>
          Indicates whether the section should be rendered
          horizontally or vertically.
        </documentation>
      </annotation>
      <simpleType>
        <restriction base="string">
          <enumeration value="horizontal"></enumeration>
          <enumeration value="vertical"></enumeration>
        </restriction>
      </simpleType>
    </attribute>
    <attribute name="role" type="string"></attribute>

    <attribute name="secondarycontent" type="boolean" use="optional"
			default="false">
      <annotation>
        <documentation>
          When true indicates that this section holds content
          that can be toggled in the UI (e.g. the UI doesn't
          display the content until the user clicks a button
          that reveals it). A schema can only have A SINGLE
          section that is `secondarycontent="true"` i.e. put
          all of the 'secondary' schema content in this single
          section and leave the 'main' content out of it.
        </documentation>
      </annotation>
    </attribute>

  </complexType>
  <element name="commands" type="tns:CommandsDeclarationsType">

  </element>
  <complexType name="commandsComplexType">
    <choice minOccurs="0" maxOccurs="unbounded">
      <element minOccurs="0" maxOccurs="unbounded" name="togglecommand"
    		type="tns:ToggleCommand">
      </element>
      <element minOccurs="0" maxOccurs="unbounded" name="command"
				type="tns:Command">
      </element>
      <element name="container" type="tns:CommandContainer"
				maxOccurs="unbounded" minOccurs="0">
      </element>
      <element name="resourcecommand" type="tns:ResourceCommand"
				minOccurs="0" maxOccurs="unbounded">
        <annotation>
          <documentation>
            This is a command that is complex enough to nned
            a custom html to define it
          </documentation>
        </annotation>
      </element>
      <element name="removecommand" type="tns:RemoveCommand"
				minOccurs="0" maxOccurs="unbounded">
      </element>
    </choice>
    <attribute use="optional" default="false"
			name="removeundeclared" type="boolean">
    </attribute>

    <attribute use="optional" name="platform">
      <simpleType>
        <restriction base="string">
          <enumeration value="web"></enumeration>
          <enumeration value="mobile"></enumeration>
        </restriction>
      </simpleType>
    </attribute>

    <attribute name="position">
      <simpleType>
        <restriction base="string">
          <enumeration value="gridtop"></enumeration>
          <enumeration value="gridbottom"></enumeration>
          <enumeration value="gridrows"></enumeration>
          <enumeration value="compositiontop"></enumeration>
          <enumeration value="detailform"></enumeration>
          <enumeration value="actions"></enumeration>
          <enumeration value="compositionbottom"></enumeration>
          <enumeration value="filter"></enumeration>
        </restriction>
      </simpleType>
    </attribute>

    <attribute name="id" type="string">
      <annotation>
        <documentation>
          The id describes a way to point to a completely
          different commandbar, other than the one declared in
          the
        </documentation>
      </annotation>
    </attribute>
  </complexType>

  <complexType name="CommandContainer">
    <choice>
      <element minOccurs="0" maxOccurs="unbounded" name="command"
				type="tns:Command">
      </element>
      <element name="container" type="tns:CommandContainer"
				minOccurs="0" maxOccurs="unbounded">
      </element>
      <element name="resourcecommand" type="tns:ResourceCommand"
				minOccurs="0" maxOccurs="unbounded">
      </element>
    </choice>
    <attribute name="id" type="string"></attribute>
    <attribute name="role" type="string"></attribute>
    <attribute name="position" type="string"></attribute>
    <attribute name="tooltip" type="string"></attribute>
    <attribute name="label" type="string"></attribute>
    <attribute name="icon" type="string"></attribute>
    <attribute name="service" type="string"></attribute>
    <attribute name="method" type="string"></attribute>
  </complexType>

  <complexType name="headerType">
    <attribute name="label" type="string" use="required"></attribute>
    <attribute name="params" type="string"></attribute>
    <attribute name="showexpression" type="string"></attribute>
    <attribute name="displacement">
      <simpleType>
        <restriction base="string">
          <enumeration value="ontop"></enumeration>
          <enumeration value="sameline"></enumeration>
        </restriction>
      </simpleType>
    </attribute>
  </complexType>

  <complexType name="baseEvent">
    <annotation>
      <documentation>
        The base event uses a service and method attribute to
        define the service.method to call. Extensions of this
        event type should be used to define type attributes
        containing enumerations of the applicable event types.
      </documentation>
    </annotation>
    <attribute name="service" type="string" use="required"></attribute>
    <attribute name="method" type="string" use="required"></attribute>
  </complexType>

  <complexType name="inputEvent">
    <complexContent mixed="false">
      <extension base="tns:baseEvent">
        <attribute name="type" use="required">
          <simpleType>
            <restriction base="string">
              <enumeration value="afterchange"></enumeration>
              <enumeration value="beforechange"></enumeration>
              <enumeration value="providerloaded">
                <annotation>
                  <documentation>
                    Hook to invoke a service right after the list of available options of a given association has been loaded
                  </documentation>
                </annotation>
              </enumeration>
            </restriction>
          </simpleType>
        </attribute>
      </extension>
    </complexContent>
  </complexType>

  <complexType name="schemaEvent">
    <complexContent mixed="false">
      <extension base="tns:baseEvent">
        <attribute name="type" use="required">
          <simpleType>
            <restriction base="string">
              <enumeration value="onviewdetail"></enumeration>
              <!-- TODO:review called multiple times-->
              <enumeration value="onload"></enumeration>
              <enumeration value="onschemafullyloaded"></enumeration>
              <enumeration
								value="beforesubmit.onvalidation">
              </enumeration>
              <enumeration
								value="beforesubmit.prevalidation">
              </enumeration>
              <enumeration
								value="beforesubmit.postvalidation">
              </enumeration>
            </restriction>
          </simpleType>
        </attribute>
      </extension>
    </complexContent>
  </complexType>

  <complexType name="queriesType">
    <sequence>
      <element name="query" type="tns:Parameter" minOccurs="1"
				maxOccurs="unbounded">
      </element>
    </sequence>
  </complexType>

  <complexType name="displayablesType">
    <sequence>
      <element name="componentdisplayable"
				type="tns:DisplayableComponentType" minOccurs="1"
				maxOccurs="unbounded">
      </element>
    </sequence>
  </complexType>

  <complexType name="DisplayableComponentType">
    <choice minOccurs="0" maxOccurs="unbounded">
      <element name="field" type="tns:Field" maxOccurs="unbounded"
				minOccurs="0">
      </element>
      <element maxOccurs="unbounded" minOccurs="0"
				ref="tns:section">

      </element>
      <element name="association" type="tns:Association"
				maxOccurs="unbounded" minOccurs="0">
      </element>
      <element name="composition" type="tns:Composition"
				maxOccurs="unbounded" minOccurs="0">
      </element>
      <element name="optionfield" type="tns:OptionField"
				maxOccurs="unbounded" minOccurs="0">
      </element>



    </choice>
    <attribute name="id" type="string" use="required"></attribute>



  </complexType>
  <complexType name="referenceComplexType">
    <attribute name="id" type="string" use="required"></attribute>
    <attribute name="showexpression" type="string"></attribute>
    <attribute name="label" type="string"></attribute>
    <attribute name="attribute" type="string"></attribute>
    <attribute name="properties" type="string"></attribute>
    <attribute name="readonly" type="string"></attribute>
  </complexType>
  <complexType name="ResourceCommand">
    <attribute name="id" type="string"></attribute>
    <attribute name="path" type="string"></attribute>
    <attribute name="position" type="string">
      <annotation>
        <documentation>
          The position will inform where to place the command,
          relative to another command present on the default
          command bar.

          It should have the syntax:

          * C1 --&gt; gruop this command with existing command
          C1 * &gt;C1--&gt; place this command right to the
          command C1 * &amp;lt;C1 --&gt; place this command
          left to the command C1

          If none provided, the command will be placed at the
          end of the bar.

          Note, inside a &quot;commands&quot; declaration the
          order should be set declaratively, by the order of
          the children



          besides, as a legacy mode, it accepts values left or
          right to place the command relatively to the default
          commands on screen
        </documentation>
      </annotation>
    </attribute>
    <attribute name="role" type="string"></attribute>
    <attribute name="remove" type="boolean"></attribute>
    <attribute name="parameters" type="string"></attribute>
  </complexType>
  <complexType name="RemoveCommand">
    <attribute name="id" type="string"></attribute>
  </complexType>

  <complexType name="Notification">
    <annotation>
      <documentation>
        Defines the notification configuration for a particular
        application.

        If the role is not defined, a default role will be
        generated using the pattern application.notifications.

        If the label is not defined, the application's title
        will be used in its place.

        The targetsschema defines the schema that the user will
        be navigated to upon clicking on the notification link.
      </documentation>
    </annotation>
    <choice minOccurs="0" maxOccurs="1">
      <element name="attributes" minOccurs="1" maxOccurs="1">
        <complexType>
          <choice minOccurs="1" maxOccurs="unbounded">
            <element name="summary" maxOccurs="1"
							minOccurs="1" type="tns:NotificationAttributeType" />

            <element name="createddate" minOccurs="1"
							maxOccurs="1" type="tns:NotificationAttributeType" />

            <element name="uid" minOccurs="1" maxOccurs="1"
							type="tns:NotificationAttributeType" />

            <element name="changeby" minOccurs="1"
							maxOccurs="1" type="tns:NotificationAttributeType" />

            <element name="extraAttributes" minOccurs="0"
							maxOccurs="1">
              <complexType>
                <choice minOccurs="0" maxOccurs="1">
                  <element name="extraAttribute"
										minOccurs="1" maxOccurs="unbounded"
										type="tns:NotificationAttributeType">
                  </element>
                </choice>
              </complexType>
            </element>

            <element name="parentAttributes" maxOccurs="1"
							minOccurs="0" type="tns:NotificationParentApplicationType" />
          </choice>
        </complexType>
      </element>
    </choice>

    <attribute name="id" type="string"></attribute>
    <attribute name="type" type="string"></attribute>
    <attribute name="role" type="string" use="required"></attribute>
    <attribute name="label" type="string"></attribute>
    <attribute name="icon" type="string"></attribute>
    <attribute name="targetSchema" type="string" use="required"></attribute>
    <attribute name="targetApplication" type="string"></attribute>
    <attribute name="whereClause" type="string"></attribute>
  </complexType>

  <complexType name="NotificationsDeclarationsType">
    <choice minOccurs="1" maxOccurs="1">
      <element name="notification" type="tns:Notification"
				minOccurs="0" maxOccurs="unbounded">
      </element>
    </choice>
  </complexType>

  <complexType name="NotificationParentApplicationType">
    <all>
      <element name="application" minOccurs="1" maxOccurs="1"
				type="tns:NotificationAttributeType">
      </element>
      <element name="parentuid" minOccurs="1" maxOccurs="1"
				type="tns:NotificationAttributeType">
      </element>
      <element name="parentid" minOccurs="1" maxOccurs="1"
				type="tns:NotificationAttributeType">
      </element>
    </all>
  </complexType>

  <complexType name="NotificationAttributeType">
    <attribute name="attribute" type="string" use="required"></attribute>
    <!--<attribute name="value" type="string" use="optional"></attribute> -->
  </complexType>



</schema>